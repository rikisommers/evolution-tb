"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AppActionCallError: () => AppActionCallError,
  ContentfulError: () => ContentfulError,
  NotFoundError: () => NotFoundError,
  ParsingError: () => ParsingError,
  ResponseStatus: () => ResponseStatus,
  callAppAction: () => callAppAction,
  callAppActionResult: () => callAppActionResult,
  getAppActionCallDetails: () => getAppActionCallDetails,
  isResultWithError: () => isResultWithError,
  safeParse: () => safeParse
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var ResponseStatus = /* @__PURE__ */ ((ResponseStatus2) => {
  ResponseStatus2["Success"] = "success";
  ResponseStatus2["RePoll"] = "re-poll";
  ResponseStatus2["Aborted"] = "aborted";
  ResponseStatus2["Error"] = "error";
  return ResponseStatus2;
})(ResponseStatus || {});

// src/callAppAction/getAppActionDetails.ts
function getAppActionCallDetails({
  api,
  appActionId,
  callId,
  spaceId,
  environmentId
}) {
  return async () => {
    var _a, _b;
    try {
      const parameters = {
        appActionId,
        callId,
        ...spaceId ? { spaceId } : {},
        ...environmentId ? { environmentId } : {}
      };
      const result = await api.appActionCall.getCallDetails(parameters);
      if (((_a = result == null ? void 0 : result.response) == null ? void 0 : _a.statusCode) && !isSuccessful((_b = result == null ? void 0 : result.response) == null ? void 0 : _b.statusCode)) {
        return { status: "error" /* Error */, error: result.response };
      }
      if (isSuccessful(result.statusCode)) {
        return { status: "success" /* Success */, result };
      }
      if (shouldRePoll(result.statusCode)) {
        return { status: "re-poll" /* RePoll */ };
      }
      return { status: "error" /* Error */, error: result };
    } catch (e) {
      return { status: "re-poll" /* RePoll */ };
    }
  };
}
function isSuccessful(statusCode) {
  return statusCode < 300;
}
function shouldRePoll(statusCode) {
  return [404, 422, 429].includes(statusCode);
}

// src/errors.ts
var ContentfulError = class extends Error {
  constructor(message, data) {
    super(message);
    this.data = data;
  }
};
var NotFoundError = class extends ContentfulError {
};
var ParsingError = class extends ContentfulError {
};
var AppActionCallError = class extends ContentfulError {
};

// src/utils.ts
function safeParse(body) {
  try {
    return JSON.parse(body);
  } catch (error) {
    throw new ParsingError("AppActionResultParsingError", {
      originalError: error
    });
  }
}
function isResultWithError(result) {
  return result.hasOwnProperty("errorMessage");
}

// src/callAppAction/callAppActionResult.ts
async function callAppActionResult({
  api,
  appActionId,
  spaceId,
  environmentId,
  callId,
  timeout,
  retryInterval,
  abortSignal
}) {
  var _a, _b;
  const pollResult = await poll(
    getAppActionCallDetails({
      appActionId,
      api,
      callId,
      spaceId,
      environmentId
    }),
    ({ status }) => status !== "re-poll" /* RePoll */,
    abortSignal,
    retryInterval,
    timeout
  );
  if (pollResult.status === "error" /* Error */) {
    throw new AppActionCallError("AppActionGetDetailsError", {
      originalError: pollResult.error
    });
  }
  if (pollResult.status === "aborted" /* Aborted */) {
    throw new AppActionCallError("AppActionGetDetailsErrorAborted", {
      originalError: null
    });
  }
  if (!((_b = (_a = pollResult == null ? void 0 : pollResult.result) == null ? void 0 : _a.response) == null ? void 0 : _b.body)) {
    throw new ParsingError("AppAction response has no body", {
      originalError: pollResult.result
    });
  }
  let parsedResult = safeParse(pollResult.result.response.body);
  if (typeof parsedResult === "string") {
    parsedResult = safeParse(parsedResult);
  }
  return parsedResult;
}
async function poll(fn, fnCondition, abortSignal, interval = 1e3, timeout = 1e3 * 100) {
  const start = Date.now();
  let result = await fn();
  while (!fnCondition(result) && !(abortSignal == null ? void 0 : abortSignal.aborted)) {
    if (start + timeout < Date.now()) {
      throw new Error("PollTimeout");
    }
    await waitFor(interval);
    result = await fn();
  }
  if (!fnCondition(result) && (abortSignal == null ? void 0 : abortSignal.aborted)) {
    result.status = "aborted" /* Aborted */;
  }
  return result;
}
async function waitFor(ms = 1e3) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/callAppAction/callAppAction.ts
async function callAppAction({
  api,
  appActionId,
  appDefinitionId,
  parameters,
  timeout,
  retryInterval,
  abortSignal,
  additionalParameters
}) {
  const defaults = api.raw.getDefaultParams();
  const spaceId = (additionalParameters == null ? void 0 : additionalParameters.spaceId) || (defaults == null ? void 0 : defaults.spaceId);
  if (!spaceId) {
    throw Error("No space id provided");
  }
  let environmentId = (additionalParameters == null ? void 0 : additionalParameters.environmentId) || (defaults == null ? void 0 : defaults.environmentId);
  if (!environmentId) {
    throw Error("No environment id provided");
  }
  const params = {
    appDefinitionId,
    appActionId,
    spaceId,
    environmentId
  };
  const createResponse = await api.appActionCall.create(params, { parameters });
  const callId = createResponse.sys.id;
  const result = await callAppActionResult({
    abortSignal,
    api,
    appActionId,
    callId,
    retryInterval,
    timeout,
    spaceId,
    environmentId
  });
  return { result, callId };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AppActionCallError,
  ContentfulError,
  NotFoundError,
  ParsingError,
  ResponseStatus,
  callAppAction,
  callAppActionResult,
  getAppActionCallDetails,
  isResultWithError,
  safeParse
});
