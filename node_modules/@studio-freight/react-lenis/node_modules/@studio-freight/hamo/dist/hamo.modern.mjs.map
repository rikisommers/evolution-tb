{"version":3,"file":"hamo.modern.mjs","sources":["../src/hooks/use-click-outside-event.js","../src/hooks/use-is-client.js","../src/hooks/use-debug.js","../src/hooks/use-document-ready-state.js","../src/hooks/use-frame.js","../src/hooks/use-interval.js","../src/hooks/use-is-touch-device.js","../src/hooks/use-is-visible.js","../src/hooks/use-media-query.js","../src/hooks/use-rect.js","../src/hooks/use-slots.js"],"sourcesContent":["/**\r\n * useOutsideClickEvent - custom hook that listens for clicks outside of a component\r\n * @param {Object} ref - React ref for the element to listen for clicks outside of\r\n * @param {Function} callback - callback function to call when a click outside of the element is detected\r\n */\r\n\r\nimport { useCallback, useEffect } from 'react'\r\n\r\nexport function useOutsideClickEvent(ref, callback) {\r\n  const handleClickOutside = useCallback(\r\n    (event) => {\r\n      if (ref.current && !ref.current.contains(event.target)) {\r\n        callback()\r\n      }\r\n    },\r\n    [ref, callback]\r\n  )\r\n\r\n  useEffect(() => {\r\n    if (ref.current) {\r\n      document.addEventListener('mousedown', handleClickOutside)\r\n      return () => {\r\n        document.removeEventListener('mousedown', handleClickOutside)\r\n      }\r\n    }\r\n  }, [handleClickOutside, ref])\r\n}\r\n","// This component is used to check if the window object is present.\r\nimport { useEffect, useState } from 'react'\r\n\r\nexport function useIsClient() {\r\n  const [isClient, setClient] = useState(false)\r\n\r\n  useEffect(() => {\r\n    setClient(true)\r\n  }, [])\r\n\r\n  return isClient\r\n}\r\n","/**\r\n * @summary A hook that returns true if the current window URL contains the\r\n *   string #debug or if we're in development mode.\r\n * @returns {Boolean} True if current window URL contains the string #debug or\r\n *   if we're in development mode, false otherwise.\r\n */\r\n\r\nimport { useMemo } from 'react'\r\nimport { useIsClient } from './use-is-client'\r\n\r\nexport function useDebug() {\r\n  const isClient = useIsClient()\r\n  const debug = useMemo(\r\n    () =>\r\n      isClient &&\r\n      (window.location.href.includes('#debug') || process.env.NODE_ENV === 'development') &&\r\n      !window.location.href.includes('#production'),\r\n    [isClient]\r\n  )\r\n\r\n  return debug\r\n}\r\n","// useDocumentReadyState.js\r\n// This code is a custom hook that returns the current document.readyState\r\n// The useLayoutEffect hook is used to set the state of the document\r\n// The useEffect hook is used to set the state of the document to 'complete' when the document is ready\r\n\r\nimport { useEffect, useState } from 'react'\r\n\r\nexport function useDocumentReadyState() {\r\n  const [readyState, setReadyState] = useState(() => {\r\n    if (typeof document !== 'undefined') {\r\n      return document.readyState\r\n    }\r\n    return 'loading'\r\n  })\r\n\r\n  useEffect(() => {\r\n    if (typeof document === 'undefined') return\r\n\r\n    setReadyState(document.readyState)\r\n\r\n    function onStateChange() {\r\n      setReadyState(document.readyState)\r\n    }\r\n\r\n    document.addEventListener('readystatechange', onStateChange, false)\r\n\r\n    return () => document.removeEventListener('readystatechange', onStateChange, false)\r\n  }, [])\r\n\r\n  return readyState\r\n}\r\n","/**\r\n * Creates a requestAnimationFrame loop and manages the lifecycle of the callback.\r\n * @param {Function} callback - A function that is called every frame.\r\n * @param {Number} priority - A number that determines the order in which the callback is called.\r\n */\r\nimport { raf } from '@studio-freight/tempus'\r\nimport { useEffect } from 'react'\r\n\r\nexport function useFrame(callback, priority = 0) {\r\n  useEffect(() => {\r\n    if (callback) {\r\n      raf.add(callback, priority)\r\n\r\n      return () => raf.remove(callback)\r\n    }\r\n  }, [callback, priority])\r\n}\r\n","/**\r\n * This function allows you to set an interval in a functional component\r\n * @param {function} callback - The callback function\r\n * @param {number} delay - The delay between each interval\r\n */\r\n\r\nimport { useEffect, useRef } from 'react'\r\n\r\nexport function useInterval(callback, delay) {\r\n  const savedCallback = useRef()\r\n  const intervalId = useRef()\r\n\r\n  useEffect(() => {\r\n    savedCallback.current = callback\r\n  })\r\n\r\n  useEffect(() => {\r\n    function tick() {\r\n      savedCallback.current()\r\n    }\r\n\r\n    if (delay !== null) {\r\n      intervalId.current = setInterval(tick, delay)\r\n      return () => clearInterval(intervalId.current)\r\n    }\r\n  }, [delay])\r\n\r\n  return () => clearInterval(intervalId.current)\r\n}\r\n","/*\r\n  This hook checks if the device has a touch screen. It checks for the touchstart event,\r\n  as well as the maxTouchPoints property on the navigator object. It also checks the\r\n  msMaxTouchPoints property, which is specific to Microsoft browsers.\r\n*/\r\n\r\nimport { useCallback, useEffect, useState } from 'react'\r\n\r\nexport function useIsTouchDevice() {\r\n  const check = useCallback(\r\n    () => 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0,\r\n    []\r\n  )\r\n\r\n  const [isTouchDevice, setIsTouchDevice] = useState(undefined)\r\n\r\n  const onResize = useCallback(() => {\r\n    setIsTouchDevice(check())\r\n  }, [check])\r\n\r\n  useEffect(() => {\r\n    onResize()\r\n    window.addEventListener('resize', onResize, { passive: true })\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', onResize, { passive: true })\r\n    }\r\n  }, [onResize])\r\n\r\n  return isTouchDevice\r\n}\r\n","// useIsVisible is a custom hook that allows you to detect when an element is\r\n// visible on the screen. It takes an object as an argument, and returns an object\r\n// with two properties: setRef and inView.\r\n\r\nimport { useCallback, useEffect, useRef, useState } from 'react'\r\n\r\nexport function useIsVisible({ root = null, rootMargin = '0px', threshold = 1.0, once = false } = {}) {\r\n  const observer = useRef()\r\n  const ref = useRef()\r\n  const [inView, setInView] = useState(false)\r\n\r\n  const setRef = useCallback((node) => {\r\n    if (!ref.current) {\r\n      ref.current = node\r\n    }\r\n  }, [])\r\n\r\n  const callbackFunction = useCallback((entries) => {\r\n    const [entry] = entries\r\n    setInView(entry.isIntersecting)\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    if (ref.current) {\r\n      observer.current = new IntersectionObserver(callbackFunction, {\r\n        root,\r\n        rootMargin,\r\n        threshold,\r\n      })\r\n      observer.current.observe(ref.current)\r\n    }\r\n    return () => {\r\n      if (observer.current) {\r\n        observer.current.disconnect()\r\n      }\r\n    }\r\n  }, [callbackFunction])\r\n\r\n  useEffect(() => {\r\n    if (once && inView) {\r\n      observer.current.disconnect()\r\n    }\r\n  }, [inView])\r\n\r\n  return { setRef, inView }\r\n}\r\n","import { useCallback, useEffect, useMemo, useState } from 'react'\r\nimport { useIsClient } from './use-is-client'\r\n\r\n/**\r\n * @name useMediaQuery\r\n * @description A React hook that detects whether a media query is true or false.\r\n * @param {string} queryString - The media query to test against.\r\n * @returns {boolean} - Whether the media query is true or false.\r\n */\r\n\r\nexport function useMediaQuery(queryString) {\r\n  const isClient = useIsClient()\r\n\r\n  const mediaQuery = useMemo(() => {\r\n    if (isClient) {\r\n      try {\r\n        return window.matchMedia(queryString)\r\n      } catch (error) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          console.error(error)\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }, [queryString, isClient])\r\n\r\n  const [isMatch, setIsMatch] = useState(undefined)\r\n\r\n  const onChange = useCallback(({ matches }) => {\r\n    setIsMatch(matches)\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    if (mediaQuery) {\r\n      onChange(mediaQuery)\r\n\r\n      mediaQuery.addEventListener('change', onChange, { passive: true })\r\n\r\n      return () => {\r\n        mediaQuery.removeEventListener('change', onChange, { passive: true })\r\n      }\r\n    }\r\n  }, [mediaQuery, onChange, isClient])\r\n\r\n  return isMatch\r\n}\r\n","import { useCallback, useEffect, useRef, useState } from 'react'\r\nimport { throttle } from 'throttle-debounce'\r\n\r\n// offsetTop function returns the offsetTop value of a DOM element.\r\n// The offsetTop value is the distance between the top of the element\r\n// and the top of the viewport.\r\nexport function offsetTop(element, accumulator = 0) {\r\n  const top = accumulator + element.offsetTop\r\n  if (element.offsetParent) {\r\n    return offsetTop(element.offsetParent, top)\r\n  }\r\n  return top\r\n}\r\n\r\n// offsetLeft function returns the offsetLeft value of a DOM element.\r\n// The offsetLeft value is the distance between the left of the element\r\n// and the left of the viewport.\r\nexport function offsetLeft(element, accumulator = 0) {\r\n  const left = accumulator + element.offsetLeft\r\n  if (element.offsetParent) {\r\n    return offsetLeft(element.offsetParent, left)\r\n  }\r\n  return left\r\n}\r\n\r\nexport function useRect({\r\n  // ignoreTransform = true,\r\n  lazy = false,\r\n  debounce = 1000,\r\n} = {}) {\r\n  const element = useRef()\r\n  const resizeObserver = useRef()\r\n\r\n  const [rect, setRect] = useState({})\r\n  const lazyRect = useRef(rect)\r\n\r\n  const resize = useCallback(() => {\r\n    if (element.current) {\r\n      const top = offsetTop(element.current)\r\n      const left = offsetLeft(element.current)\r\n\r\n      lazyRect.current = { ...lazyRect.current, top, left }\r\n      if (!lazy) {\r\n        setRect(lazyRect.current)\r\n      }\r\n    }\r\n  }, [lazy])\r\n\r\n  // resize if body height changes\r\n  useEffect(() => {\r\n    const callback = throttle(debounce, resize)\r\n    const resizeObserver = new ResizeObserver(callback)\r\n    resizeObserver.observe(document.body)\r\n\r\n    return () => {\r\n      resizeObserver.disconnect()\r\n      callback.cancel({ upcomingOnly: true })\r\n    }\r\n  }, [debounce, resize])\r\n\r\n  const onResizeObserver = useCallback(\r\n    ([entry]) => {\r\n      const { width, height } = entry.contentRect\r\n\r\n      lazyRect.current = { ...lazyRect.current, width, height }\r\n      if (!lazy) {\r\n        setRect(lazyRect.current)\r\n      }\r\n    },\r\n    [lazy]\r\n  )\r\n\r\n  const getRect = useCallback(() => lazyRect.current, [])\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      // avoid strict mode double execution\r\n      if (process.env.NODE_ENV !== 'development') {\r\n        // disconnect resizeObserver on unmount\r\n        resizeObserver.current?.disconnect()\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  const setRef = useCallback(\r\n    (node) => {\r\n      if (!node || node === element.current) return\r\n\r\n      resizeObserver.current?.disconnect()\r\n      resizeObserver.current = new ResizeObserver(onResizeObserver)\r\n      resizeObserver.current.observe(node)\r\n      element.current = node\r\n    },\r\n    [resize]\r\n  )\r\n\r\n  return [setRef, lazy ? getRect : rect]\r\n}\r\n","// This code is used to extract the contents of a component's children and return them as an array.\r\n// The code accepts two arguments, the names of the components that it should extract, and the children to extract from.\r\n// The code returns an array of the children of the components passed in the types argument.\r\n// based on:\r\n// https://medium.com/swlh/bring-vue-named-slots-to-react-87684188f18e\r\n\r\nimport { useMemo } from 'react'\r\n\r\nexport function useSlots(types = [], children = []) {\r\n  const _children = useMemo(() => children && [children].flat(), [children])\r\n  const _types = useMemo(() => types && [types].flat(), [types])\r\n  const slots = useMemo(() => {\r\n    if (!_children || !_types) {\r\n      return\r\n    }\r\n\r\n    const slots = _types.map((type) => _children.find((el) => el.type === type)?.props.children)\r\n\r\n    return types[0] ? slots : slots[0]\r\n  }, [_children, _types])\r\n\r\n  return slots\r\n}\r\n"],"names":["useOutsideClickEvent","ref","callback","useCallback","event","current","contains","target","useEffect","document","addEventListener","handleClickOutside","removeEventListener","useIsClient","isClient","setClient","useState","useDebug","useMemo","window","location","href","includes","process","env","NODE_ENV","useDocumentReadyState","readyState","setReadyState","onStateChange","useFrame","priority","raf","add","remove","useInterval","delay","useRef","savedCallback","intervalId","setInterval","clearInterval","useIsTouchDevice","check","navigator","maxTouchPoints","msMaxTouchPoints","isTouchDevice","setIsTouchDevice","undefined","onResize","passive","useIsVisible","root","rootMargin","threshold","once","inView","setInView","setRef","node","callbackFunction","entries","entry","isIntersecting","observer","IntersectionObserver","observe","disconnect","queryString","mediaQuery","matchMedia","error","console","isMatch","setIsMatch","onChange","matches","offsetTop","element","accumulator","top","offsetParent","offsetLeft","left","useRect","lazy","debounce","resizeObserver","rect","setRect","lazyRect","resize","_extends","throttle","ResizeObserver","body","cancel","upcomingOnly","onResizeObserver","width","height","contentRect","getRect","_resizeObserver$curre","_resizeObserver$curre2","useSlots","types","children","_children","flat","_types","slots","map","type","find","el","_children$find","props"],"mappings":"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"}