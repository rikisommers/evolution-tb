"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logToTaskOutput = exports.setupLogging = exports.writeErrorLogFile = exports.displayErrorLog = exports.formatLogMessageLogfile = exports.formatLogMessageOneLine = exports.logEmitter = void 0;
const format_1 = __importDefault(require("date-fns/format"));
const parseISO_1 = __importDefault(require("date-fns/parseISO"));
const figures_1 = __importDefault(require("figures"));
const node_events_1 = __importDefault(require("node:events"));
const node_fs_1 = require("node:fs");
const node_stream_1 = require("node:stream");
const promises_1 = require("node:stream/promises");
const get_entity_name_1 = __importDefault(require("./get-entity-name"));
exports.logEmitter = new node_events_1.default();
function extractErrorInformation(error) {
    const source = error.originalError || error;
    try {
        const data = JSON.parse(source.message);
        if (data && typeof data === 'object') {
            return data;
        }
    }
    catch (err) {
        throw new Error('Unable to extract API error data');
    }
}
function formatLogMessageOneLine(logMessage) {
    const { level } = logMessage;
    if (!level) {
        return logMessage.toString().replace(/\s+/g, ' ');
    }
    if (level === 'info') {
        return logMessage.info;
    }
    if (level === 'warning') {
        return logMessage.warning;
    }
    try {
        // Display enhanced API error message when available
        const errorOutput = [];
        const data = extractErrorInformation(logMessage.error);
        if ('status' in data || 'statusText' in data) {
            const status = [data.status, data.statusText].filter((a) => a).join(' - ');
            errorOutput.push(`Status: ${status}`);
        }
        if ('message' in data) {
            errorOutput.push(`Message: ${data.message}`);
        }
        if ('entity' in data) {
            errorOutput.push(`Entity: ${(0, get_entity_name_1.default)(data.entity)}`);
        }
        if ('details' in data && 'errors' in data.details) {
            const errorList = data.details.errors.map((error) => error.details || error.name);
            errorOutput.push(`Details: ${errorList.join(', ')}`);
        }
        if ('requestId' in data) {
            errorOutput.push(`Request ID: ${data.requestId}`);
        }
        return `${logMessage.error.name}: ${errorOutput.join(' - ')}`;
    }
    catch (err) {
        // Fallback for errors without API information
        return logMessage.error.toString().replace(/\s+/g, ' ');
    }
}
exports.formatLogMessageOneLine = formatLogMessageOneLine;
function formatLogMessageLogfile(logMessage) {
    const { level } = logMessage;
    if (level === 'info' || level === 'warning') {
        return logMessage;
    }
    if (!logMessage.error) {
        // Enhance node errors to logMessage format
        logMessage.error = logMessage;
    }
    try {
        // Enhance error with extracted API error log
        const data = extractErrorInformation(logMessage.error);
        const errorOutput = Object.assign({}, logMessage.error, { data });
        delete errorOutput.message;
        logMessage.error = errorOutput;
    }
    catch (err) {
        // Fallback for errors without API information
        if (logMessage.error.stack) {
            logMessage.error.stacktrace = logMessage.error.stack
                .toString()
                .split(/\n +at /);
        }
    }
    // Listr attaches the whole context to error messages.
    // Remove it to avoid error log file pollution.
    if (typeof logMessage.error === 'object' && 'context' in logMessage.error) {
        delete logMessage.error.context;
    }
    return logMessage;
}
exports.formatLogMessageLogfile = formatLogMessageLogfile;
// Display all errors
function displayErrorLog(errorLog) {
    if (errorLog.length) {
        const count = errorLog.reduce((count, curr) => {
            if (Object.prototype.hasOwnProperty.call(curr, 'warning')) {
                count.warnings++;
            }
            else if (Object.prototype.hasOwnProperty.call(curr, 'error')) {
                count.errors++;
            }
            return count;
        }, { warnings: 0, errors: 0 });
        console.log(`\n\nThe following ${count.errors} errors and ${count.warnings} warnings occurred:\n`);
        errorLog
            .map((logMessage) => `${(0, format_1.default)((0, parseISO_1.default)(logMessage.ts), 'HH:mm:ss')} - ${formatLogMessageOneLine(logMessage)}`)
            .map((logMessage) => console.log(logMessage));
        return;
    }
    console.log('No errors or warnings occurred');
}
exports.displayErrorLog = displayErrorLog;
/**
 * Write all log messages instead of infos to the error log file
 * @param {import('node:fs').PathLike} destination
 * @param {Record<string, unknown>[]} errorLog
 * @returns {Promise<void>}
 */
async function writeErrorLogFile(destination, errorLog) {
    const formatLogTransformer = new node_stream_1.Transform({
        objectMode: true,
        transform: (chunk, encoding, callback) => {
            const formattedChunk = formatLogMessageLogfile(chunk);
            callback(null, Buffer.from(JSON.stringify(formattedChunk)));
        }
    });
    const logFileWriteStream = (0, node_fs_1.createWriteStream)(destination);
    try {
        await (0, promises_1.pipeline)([
            node_stream_1.Readable.from(errorLog),
            formatLogTransformer,
            logFileWriteStream
        ]);
        console.log('\nStored the detailed error log file at:');
        console.log(destination);
    }
    catch (err) {
        // avoid crashing when writing the log file fails
        console.error(err);
    }
}
exports.writeErrorLogFile = writeErrorLogFile;
/**
 * Init listeners for log messages, transform them into proper format and logs/displays them
 * @param {Record<string,unknown>[]} log
 * @returns {Promise<void>}
 */
function setupLogging(log) {
    function errorLogger(level, error) {
        const logMessage = {
            ts: new Date().toJSON(),
            level,
            [level]: error
        };
        if (level !== 'info') {
            log.push(logMessage);
        }
        exports.logEmitter.emit('display', logMessage);
    }
    exports.logEmitter.addListener('info', (error) => errorLogger('info', error));
    exports.logEmitter.addListener('warning', (error) => errorLogger('warning', error));
    exports.logEmitter.addListener('error', (error) => errorLogger('error', error));
}
exports.setupLogging = setupLogging;
/**
 * Format log message to display them as task status
 * @template {Ctx}
 * @param {import('listr').ListrTaskWrapper<Ctx>} task
 */
function logToTaskOutput(task) {
    function logToTask(logMessage) {
        const content = formatLogMessageOneLine(logMessage);
        const symbols = {
            info: figures_1.default.tick,
            warning: figures_1.default.warning,
            error: figures_1.default.cross
        };
        task.output = `${symbols[logMessage.level]} ${content}`.trim();
    }
    const startTime = Date.now();
    exports.logEmitter.on('display', logToTask);
    return () => {
        const seconds = Math.ceil((Date.now() - startTime) / 1000);
        task.title = `${task.title} (${seconds}s)`;
        exports.logEmitter.removeListener('display', logToTask);
    };
}
exports.logToTaskOutput = logToTaskOutput;
