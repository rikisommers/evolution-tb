"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMessageLogStructure = void 0;
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const filterBase = (item) => {
    return `contentTypes/${item.entity.sys.id}`;
};
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const patchOperationToChangeType = {
    replace: 'update',
    move: 'update',
    copy: 'update',
    remove: 'delete',
    add: 'add'
};
const valueTypeFormatter = (value) => {
    if (typeof value === 'string') {
        return `"${value}"`;
    }
    return value;
};
const arrowSymbol = (direction) => direction === 'up' ? '↑' : '↓';
const tab = (width) => ' '.repeat(width);
const Formatter = {
    id: (value) => chalk_1.default.yellow(value),
    value: (value) => valueTypeFormatter(value),
    title: (value) => tab(1) + value,
    subtitle: (value) => tab(3) + value,
    details: (value) => tab(3) + chalk_1.default.bold.dim(value)
};
function createMessageLogStructure(targetModel, changesetItems) {
    const toBeAdded = changesetItems
        .filter(item => item.changeType === 'add')
        .map(item => {
        return {
            filterStr: filterBase(item),
            changeType: 'add',
            level: 0,
            messages: [
                Formatter.title('ContentType'),
                Formatter.title(`id: ${Formatter.id(item.entity.sys.id)}`)
            ]
        };
    });
    const toBeDeleted = changesetItems
        .filter(item => item.changeType === 'delete')
        .map(item => {
        return {
            filterStr: filterBase(item),
            changeType: 'delete',
            level: 0,
            messages: [
                Formatter.title('ContentType'),
                Formatter.title(`id: ${Formatter.id(item.entity.sys.id)}`)
            ]
        };
    });
    const toBeChanged = changesetItems
        .filter(item => item.changeType === 'update')
        // hacking types
        .map(item => item)
        .reduce((contentTypeMessages, item) => {
        contentTypeMessages.push({
            filterStr: filterBase(item),
            changeType: 'update',
            level: 0,
            messages: [
                Formatter.title('ContentType'),
                Formatter.title(`id: ${Formatter.id(item.entity.sys.id)}`)
            ]
        });
        for (const operation of item.patch) {
            const messages = [];
            let key = (0, utils_1.getChangeKey)(operation);
            const isFieldValueChange = operation.path.startsWith('/fields/');
            const isChangeOperation = operation.op === 'replace';
            const isAddOperation = operation.op === 'add';
            const isMoveOperation = operation.op === 'move';
            if (isFieldValueChange) {
                // if it is a field move operation, we need the initial field index
                // to retrieve the field id
                const indexForFieldId = isMoveOperation
                    ? (0, utils_1.fieldIndex)(operation.from)
                    : (0, utils_1.fieldIndex)(operation.path);
                key = (0, utils_1.getFieldIdForIndex)(targetModel, item.entity.sys.id, indexForFieldId);
                // at this point, the field doesn't exist on the target model
                if (isAddOperation) {
                    key = operation.value.id;
                }
                messages.push(Formatter.title('Field'));
            }
            else {
                messages.push(Formatter.title('ContentType'));
            }
            if (isFieldValueChange) {
                messages.push(Formatter.subtitle(`id: ${Formatter.id(key)}`));
            }
            else {
                messages.push(Formatter.details(`property: ${key}`));
            }
            const fieldValueChange = (0, utils_1.fieldChange)(operation);
            const isNestedMove = (0, utils_1.isNestedMoveOperation)(operation);
            if (fieldValueChange) {
                if (isNestedMove) {
                    const propChain = (0, utils_1.getNestedPropertyNames)(operation);
                    messages.push(Formatter.details(`property: ${propChain.join(' -> ')}`));
                }
                else if (fieldValueChange.length > 0) {
                    messages.push(Formatter.details(`property: ${fieldValueChange}`));
                }
            }
            if (isChangeOperation) {
                messages.push(Formatter.details(`value: ${Formatter.value(operation.value)}`));
            }
            if (isAddOperation) {
                const stringifiedValue = JSON.stringify(operation.value, null, 2);
                const valueInLines = stringifiedValue.split('\n');
                // we display the first three lines, and indicate that it's truncated with "..."
                messages.push(Formatter.details(`value:`));
                [...valueInLines.slice(1, 4), '  ...'].map(line => messages.push(Formatter.details(line)));
            }
            if (isMoveOperation) {
                if (isNestedMove) {
                    messages.push(Formatter.details(`position: ↕ order changed`));
                }
                else {
                    const fromIndex = (0, utils_1.getLastIndexFromPath)(operation.from);
                    const toIndex = (0, utils_1.getLastIndexFromPath)(operation.path);
                    const direction = fromIndex < toIndex ? 'down' : 'up';
                    messages.push(Formatter.details(`position: ${arrowSymbol(direction)} moved ${direction}`));
                }
            }
            contentTypeMessages.push({
                filterStr: `${filterBase(item)}${operation.path}`,
                level: 1,
                changeType: patchOperationToChangeType[operation.op],
                messages
            });
        }
        return (0, lodash_1.orderBy)(contentTypeMessages, ['type']);
    }, []);
    return {
        added: toBeAdded,
        deleted: toBeDeleted,
        updated: toBeChanged
    };
}
exports.createMessageLogStructure = createMessageLogStructure;
