"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNestedPropertyNames = exports.getLastIndexFromPath = exports.isNestedMoveOperation = exports.fieldChange = exports.fieldIndex = exports.getFieldIdForIndex = exports.getChangeKey = void 0;
const getChangeKey = (operation) => {
    const parts = operation.path.split('/');
    return parts[parts.length - 1];
};
exports.getChangeKey = getChangeKey;
const getFieldIdForIndex = (model, contentTypeId, index) => {
    const matchedContentType = model.find(contentType => contentType.sys.id === contentTypeId);
    if (matchedContentType && matchedContentType.fields.length > index) {
        return matchedContentType.fields[index].id;
    }
    return 'unknown';
};
exports.getFieldIdForIndex = getFieldIdForIndex;
const fieldIndex = (path) => {
    if (!path.startsWith('/fields')) {
        return -1;
    }
    return parseInt(path.split('/')[2]);
};
exports.fieldIndex = fieldIndex;
const fieldChange = (operation) => {
    if (!operation.path.startsWith('/fields')) {
        return '';
    }
    return operation.path.split('/')[3];
};
exports.fieldChange = fieldChange;
// Util functions for move operations
const isNestedMoveOperation = (operation) => {
    return (operation.op === 'move' &&
        operation.path.split('/').filter(x => x !== '').length > 2);
};
exports.isNestedMoveOperation = isNestedMoveOperation;
const getLastIndexFromPath = (path) => {
    const stringIndex = path.split('/').pop();
    const lastIndex = parseInt(stringIndex, 10);
    if (isNaN(lastIndex)) {
        return -1;
    }
    return lastIndex;
};
exports.getLastIndexFromPath = getLastIndexFromPath;
const getNestedPropertyNames = (operation) => operation.path
    .split('/')
    // we want any property that is within fields, we filter out indices
    .filter(x => x !== 'fields' && x !== '' && isNaN(parseInt(x, 10)));
exports.getNestedPropertyNames = getNestedPropertyNames;
