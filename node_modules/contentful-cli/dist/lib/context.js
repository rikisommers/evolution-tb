"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { readFile, writeFile } = require('fs/promises');
const { resolve } = require('path');
const { homedir } = require('os');
const findUp = require('find-up');
const { proxyStringToObject } = require('./utils/proxy');
let context;
let configPath;
function getConfigPath() {
    return __awaiter(this, void 0, void 0, function* () {
        const pathOverride = process.env.CONTENTFUL_CONFIG_FILE;
        if (pathOverride) {
            return pathOverride;
        }
        const contentfulrc = '.contentfulrc.json';
        const defaultPath = resolve(homedir(), contentfulrc);
        const nestedConfigPath = yield findUp(contentfulrc);
        configPath = nestedConfigPath || defaultPath;
        return configPath;
    });
}
module.exports.getConfigPath = getConfigPath;
function getContext() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!context) {
            context = yield loadRuntimeConfig();
        }
        return context;
    });
}
module.exports.getContext = getContext;
function setContext(newContext) {
    context = Object.assign(Object.assign({}, context), newContext);
}
module.exports.setContext = setContext;
function emptyContext() {
    context = null;
}
module.exports.emptyContext = emptyContext;
function loadProxyFromEnv(env) {
    const proxyString = env['https_proxy'] ||
        env['HTTPS_PROXY'] ||
        env['http_proxy'] ||
        env['HTTP_PROXY'];
    // Delete all potential proxy keys `axios` might use
    delete env['http_proxy'];
    delete env['HTTP_PROXY'];
    delete env['https_proxy'];
    delete env['HTTPS_PROXY'];
    if (!proxyString) {
        return {};
    }
    const proxy = proxyStringToObject(proxyString);
    return { proxy };
}
function loadRuntimeConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        const configPath = yield getConfigPath();
        let configFileContent;
        try {
            const content = yield readFile(configPath);
            configFileContent = JSON.parse(content.toString());
        }
        catch (e) {
            if (e.code !== 'ENOENT') {
                throw e;
            }
            configFileContent = {};
        }
        const environment = loadProxyFromEnv(process.env);
        context = Object.assign(Object.assign(Object.assign({}, context), configFileContent), environment);
        return context;
    });
}
function storeRuntimeConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        const contextToStore = {
            managementToken: context.managementToken,
            activeSpaceId: context.activeSpaceId,
            activeEnvironmentId: context.activeEnvironmentId,
            host: context.host,
            proxy: context.proxy,
            rawProxy: context.rawProxy
        };
        // Don't write it out unless it's explicitly asked for
        if (context.insecure) {
            contextToStore.insecure = context.insecure;
        }
        return writeFile(yield getConfigPath(), JSON.stringify(contextToStore, null, 2) + '\n');
    });
}
module.exports.storeRuntimeConfig = storeRuntimeConfig;
