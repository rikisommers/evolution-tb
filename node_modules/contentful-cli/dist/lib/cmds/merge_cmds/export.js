"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callExportAppAction = void 0;
const chalk_1 = __importDefault(require("chalk"));
const listr_1 = __importDefault(require("listr"));
const path_1 = __importDefault(require("path"));
const app_actions_1 = require("../../utils/app-actions");
const app_actions_config_1 = require("../../utils/app-actions-config");
const async_1 = require("../../utils/async");
const fs_1 = require("../../utils/fs");
const log_1 = require("../../utils/log");
const errors_1 = require("../../utils/merge/errors");
const prepare_merge_command_1 = require("../../utils/merge/prepare-merge-command");
module.exports.command = 'export';
module.exports.desc = 'Export diff between two environments as a migration';
module.exports.builder = (yargs) => {
    return yargs
        .usage('Usage: contentful merge export')
        .option('source-environment-id', {
        alias: 'se',
        type: 'string',
        demandOption: true,
        describe: 'Source environment id'
    })
        .option('target-environment-id', {
        alias: 'te',
        type: 'string',
        demandOption: true,
        describe: 'Target environment id'
    })
        .option('yes', {
        alias: 'y',
        describe: 'Confirm Merge app installation without prompt'
    })
        .option('output-file', {
        alias: 'o',
        type: 'string',
        describe: 'Output file. It defaults to ./migrations/<timestamp>-<space-id>-<source-environment-id>-<target-environment-id>.js'
    });
};
const callExportAppAction = ({ api, appDefinitionId, createChangesetActionId, exportActionId, sourceEnvironmentId, targetEnvironmentId, spaceId }) => __awaiter(void 0, void 0, void 0, function* () {
    return new listr_1.default([
        {
            title: 'Compute differences',
            // use wrapTask
            task: (ctx, task) => __awaiter(void 0, void 0, void 0, function* () {
                task.output = (0, chalk_1.default) `calculating differences`;
                const actionResponse = yield (0, app_actions_1.callCreateChangesetWithResponse)({
                    api: ctx.api,
                    appDefinitionId: ctx.appDefinitionId,
                    appActionId: ctx.createChangesetActionId,
                    parameters: {
                        sourceEnvironmentId: ctx.sourceEnvironmentId,
                        targetEnvironmentId: ctx.targetEnvironmentId
                    },
                    spaceId: ctx.spaceId,
                    // We use the target environment as this environment needs to have the merge app installed
                    // and the context environment might not have it installed and not need it. Using directly
                    // the target env saves us installations. We could have used the source environment also.
                    environmentId: ctx.targetEnvironmentId
                }).catch(() => {
                    throw new Error(errors_1.mergeErrors['ErrorInDiffCreation']);
                });
                task.output = (0, chalk_1.default) `fetching differences`;
                // eslint-disable-next-line require-atomic-updates
                ctx.changesetRef = actionResponse.sys.id;
            })
        },
        {
            title: (0, chalk_1.default) `Create migration`,
            task: (ctx) => __awaiter(void 0, void 0, void 0, function* () {
                const { migration } = yield (0, app_actions_1.getExportMigration)({
                    api: ctx.api,
                    appDefinitionId: ctx.appDefinitionId,
                    appActionId: ctx.exportActionId,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    changesetRef: ctx.changesetRef,
                    spaceId: ctx.spaceId,
                    targetEnvironmentId: ctx.targetEnvironmentId
                }).catch(e => {
                    if ((e === null || e === void 0 ? void 0 : e.message) === 'PollTimeout') {
                        throw new Error(errors_1.mergeErrors['ExportPollTimeout']);
                    }
                    throw new Error(errors_1.mergeErrors['MigrationCouldNotBeExported']);
                });
                // eslint-disable-next-line require-atomic-updates
                ctx.migration = migration;
            })
        }
    ]).run({
        api,
        appDefinitionId: appDefinitionId,
        createChangesetActionId,
        exportActionId,
        sourceEnvironmentId,
        targetEnvironmentId,
        spaceId: spaceId
    });
});
exports.callExportAppAction = callExportAppAction;
const exportEnvironmentMigration = ({ context, sourceEnvironmentId, targetEnvironmentId, yes = false, outputFile }) => __awaiter(void 0, void 0, void 0, function* () {
    const { activeSpaceId, host, client, mergeAppId } = yield (0, prepare_merge_command_1.prepareMergeCommand)({
        context,
        sourceEnvironmentId,
        targetEnvironmentId,
        yes
    });
    let outputTarget;
    try {
        outputTarget = (0, fs_1.getPath)(outputFile ||
            path_1.default.join('migrations', `${Date.now()}-${activeSpaceId}-${sourceEnvironmentId}-${targetEnvironmentId}.js`));
        yield (0, fs_1.ensureDir)(path_1.default.dirname(outputTarget));
    }
    catch (e) {
        throw new Error('Something failed with the output file. Ensure the path exists and is writable.');
    }
    const result = yield (0, exports.callExportAppAction)({
        api: client,
        appDefinitionId: mergeAppId,
        createChangesetActionId: (0, app_actions_config_1.getAppActionId)('create-changeset', host),
        exportActionId: (0, app_actions_config_1.getAppActionId)('export-changeset', host),
        sourceEnvironmentId,
        targetEnvironmentId,
        spaceId: activeSpaceId
    });
    if (result.migration) {
        yield (0, fs_1.writeFileP)(outputTarget, result.migration);
        (0, log_1.success)(`âœ… Migration exported to ${outputTarget}.`);
    }
    else {
        (0, log_1.error)(`failed to save migration file!`);
    }
});
module.exports.handler = (0, async_1.handleAsyncError)(exportEnvironmentMigration);
