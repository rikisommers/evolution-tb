"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require('fs');
const { omitBy, assign, isUndefined } = require('lodash');
const { readFileP } = require('../../../utils/fs');
const { getFieldType } = require('./convert-field-type');
const { ValidationError } = require('../../../utils/error');
module.exports = function prepareData(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const descriptor = (yield getDescriptor(argv.descriptor)) || {};
        const args = getExtensionData(argv);
        const descriptorArgs = getExtensionData(descriptor);
        // Enable overwriting the src or srcdoc via command arguments.
        // Will allow passing localhost as src for development and
        // using a html file via srcdoc for production.
        if ('src' in args || 'srcdoc' in args) {
            delete descriptorArgs.src;
            delete descriptorArgs.srcdoc;
        }
        return omitBy({
            id: argv.id || descriptor.id,
            extension: assign({}, descriptorArgs, args),
            parameters: getInstallationParameterValues(argv)
        }, isUndefined);
    });
};
function getDescriptor(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
        const DEFAULT_PATH = './extension.json';
        const path = filepath || (fs.existsSync(DEFAULT_PATH) && DEFAULT_PATH);
        if (path) {
            const file = yield readFileP(path, 'utf8');
            try {
                return JSON.parse(file);
            }
            catch (e) {
                throw new ValidationError('Error parsing descriptor file');
            }
        }
    });
}
function getExtensionData(data) {
    return omitBy({
        name: data.name,
        fieldTypes: data.fieldTypes
            ? data.fieldTypes.map(getFieldType)
            : undefined,
        src: data.src,
        srcdoc: data.srcdoc,
        sidebar: data.sidebar,
        parameters: data.parameters
    }, isUndefined);
}
function getInstallationParameterValues(data) {
    if (data.installationParameters) {
        try {
            return JSON.parse(data.installationParameters);
        }
        catch (e) {
            throw new ValidationError('Could not parse JSON string of installation parameter values');
        }
    }
}
