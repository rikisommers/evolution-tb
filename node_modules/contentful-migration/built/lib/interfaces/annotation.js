"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAnnotationAssignment = exports.availableAnnotations = exports.Annotation = void 0;
const lodash_1 = __importDefault(require("lodash"));
class Annotation {
    constructor(annotationData) {
        this.annotationData = annotationData;
    }
    static isValidId(id) {
        return Object.keys(exports.availableAnnotations).includes(id);
    }
    /**
     * Verifies if given assignment complies with the annotation definition
     */
    validateAssignment(assignment) {
        const { targets } = this.annotationData;
        const isValidTarget = targets.some((target) => {
            if (target.type !== assignment.target.type) {
                return false;
            }
            return (!target.accept ||
                target.accept.some((requirements) => lodash_1.default.isMatch(assignment.target.data, requirements)));
        });
        if (!isValidTarget) {
            return {
                type: 'InvalidPayload',
                message: `Invalid annotation assignment for annotation "${this.annotationData.id}". Annotation target mismatch`
            };
        }
    }
}
exports.Annotation = Annotation;
exports.availableAnnotations = {
    'Contentful:AggregateRoot': new Annotation({
        id: 'Contentful:AggregateRoot',
        targets: [
            {
                type: 'ContentType'
            }
        ]
    }),
    'Contentful:ManagedByEnvironmentTemplate': new Annotation({
        id: 'Contentful:ManagedByEnvironmentTemplate',
        targets: [
            {
                type: 'ContentType'
            }
        ]
    }),
    'Contentful:AggregateComponent': new Annotation({
        id: 'Contentful:AggregateComponent',
        targets: [
            {
                type: 'ContentTypeField',
                accept: [
                    {
                        type: 'Link',
                        linkType: 'Entry'
                    },
                    {
                        type: 'Array',
                        items: {
                            type: 'Link',
                            linkType: 'Entry'
                        }
                    }
                ]
            }
        ]
    }),
    'Contentful:GraphQLFieldResolver': new Annotation({
        id: 'Contentful:GraphQLFieldResolver',
        targets: [
            {
                type: 'ContentTypeField',
                accept: [
                    {
                        type: 'Symbol'
                    },
                    {
                        type: 'Array',
                        items: {
                            type: 'Symbol'
                        }
                    },
                    {
                        type: 'Object'
                    }
                ]
            }
        ]
    })
};
function validateAnnotationAssignment(assignment) {
    const annotation = exports.availableAnnotations[assignment.annotationId];
    if (!annotation) {
        return {
            type: 'InvalidPayload',
            message: `Invalid annotation assignment. Annotation "${assignment.annotationId}" not found`
        };
    }
    return annotation.validateAssignment(assignment);
}
exports.validateAnnotationAssignment = validateAnnotationAssignment;
//# sourceMappingURL=annotation.js.map